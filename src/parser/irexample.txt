// core types: u8, i8, u16, i16, u32, i32, u64, i64, f32, f64
// pointer types: ptr(type), funcptr(returntype, (arg1type, arg2type, ...))
// composite types: structs, array(type, len)




/*
f32 return_literal()
{
    f32 x;
exit:
    return 16.1f32;
}
*/

struct Vec2
{
    f32 x;
    f32 y;
}

void add_to_x(ptr(Vec2) vec)
{
    (*vec).x = (*vec).x + 1.0f32;
    
    return;
}

void struct_literal()
{
    Vec2 val = Vec2 { 1.0f32, 0.5f32 };
    print_bytes(((&val) bit_as ptr(u8)), 8u64);
    
    val = Vec2 { 2.0001f32, 0.4999342f32 };
    print_bytes(((&val) bit_as ptr(u8)), 8u64);
    
    add_to_x(&val);
    print_bytes(((&val) bit_as ptr(u8)), 8u64);
    
    return;
}

/*


f32 plus_one(f32 a)
{
    return a + 1.0f32;
}

funcptr(f32, (f32)) r_add_one()
{
    return plus_one;
}

f32 add(f32 a, f32 b)
{
    Vec2 vec;
    vec.x = a;
    vec.y = b;
    a = vec.x + vec.y - 1.0f32;
    
    array(f32, 2) list;
    list[0i64] = a;
    *(&(list[1i64])) = b;
    
    f32 asdf = r_add_one()(list[0i64] + list[1i64]);
    return r_add_one()(a + b);
}


f32 tenloop()
{
    f32 x;
    x = 0.0f32;
    
loop_head:
    x = x + 1.061f32;
    
    if(x < 10.0f32)
        goto loop_head;
    
    return x;
}
*/

f32 func_gravity()
{
    u64 i = 0u64;
    f64 yvel = 0.0f64;
    f64 y = 0.0f64;
    f64 gravity = 9.8f64;
    f64 delta = 0.001f64;
    
head:
    yvel = yvel + delta*gravity*0.5f64;
    y = y + yvel*delta;
    yvel = yvel + delta*gravity*0.5f64;
    
    i = i + 1u64;
    
    if (i < 500000000u64)
        goto head;
    
    return (y as f32);
}

void returns_void(f32 a)
{
    a = a;
    return;
}

/*
// TODO
void void_ptr_arg(ptr(void) a)
{
    return;
}
*/

void array_literal()
{
    array(u8, 10) funtime = [16u8, 201u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
    print_bytes(((&funtime) bit_as ptr(u8)), 10u64);
    funtime = [61u8, 1u8, 0u8, 0u8, 0u8, 1u8, 2u8, 3u8, 0u8, 42u8];
    print_bytes(((&funtime) bit_as ptr(u8)), 10u64);
    return;
}
void print_garbage()
{
    array(u8, 16) garbage;
    
    garbage[ 0i64] = 16u8;
    garbage[ 1i64] = 1u8;
    garbage[ 2i64] = 175u8;
    garbage[ 3i64] = 15u8;
    garbage[ 4i64] = 115u8;
    garbage[ 5i64] = 255u8;
    garbage[ 6i64] = 94u8;
    garbage[ 7i64] = 114u8;
    garbage[ 8i64] = 62u8;
    garbage[ 9i64] = 0u8;
    garbage[10i64] = 183u8;
    garbage[11i64] = 123u8;
    garbage[12i64] = 86u8;
    garbage[13i64] = 63u8;
    garbage[14i64] = 85u8;
    garbage[15i64] = 1u8;
    
    print_bytes(((&garbage) bit_as ptr(u8)), 16u64);
    
    u8 a;
    i32 r;
    
    // memcmp not implemented
    //a = 16u8;
    //r = intrinsic_memcmp(&a, &garbage[0i64], 1u64);
    //print_bytes((&r bit_as ptr(u8)), 4u64);
    //
    //a = 17u8;
    //r = intrinsic_memcmp(&a, &garbage[0i64], 1u64);
    //print_bytes((&r bit_as ptr(u8)), 4u64);
    //
    //a = 15u8;
    //r = intrinsic_memcmp(&a, &garbage[0i64], 1u64);
    //print_bytes((&r bit_as ptr(u8)), 4u64);
    
    return;
}


struct Vector3 {
    f64 x;
    f64 y;
    f64 z;
}

Vector3 vec3_mul_f64(Vector3 a, f64 b)
{
    a.x = a.x * b;
    a.y = a.y * b;
    a.z = a.z * b;
    return a;
}
Vector3 vec3_mul_vec3(Vector3 a, Vector3 b)
{
    a.x = a.x * b.x;
    a.y = a.y * b.y;
    a.z = a.z * b.z;
    return a;
}
Vector3 vec3_add_vec3(Vector3 a, Vector3 b)
{
    a.x = a.x + b.x;
    a.y = a.y + b.y;
    a.z = a.z + b.z;
    return a;
}
Vector3 vec3_sub_vec3(Vector3 a, Vector3 b)
{
    a.x = a.x - b.x;
    a.y = a.y - b.y;
    a.z = a.z - b.z;
    return a;
}
f64 vec3_sq_length(Vector3 a)
{
    return a.x*a.x + a.y*a.y + a.z*a.z;
}
f64 vec3_length(Vector3 a)
{
    return sqrt(vec3_sq_length(a));
}

struct Body {
    Vector3 pos;
    Vector3 vel;
    f64 mass;
}

void advance(ptr(array(Body, 5)) bodies, f64 delta)
{
    i64 i = 0i64;
    loop_outer:
        f64 mass = (*bodies)[i].mass;
        Vector3 pos = (*bodies)[i].pos;
        Vector3 vel = (*bodies)[i].vel;
        
        i64 j = i;
        goto loop_inner_bottom;
        
        loop_inner:
            f64 mass2 = (*bodies)[j].mass;
            Vector3 pos2 = (*bodies)[j].pos;
            Vector3 vel2 = (*bodies)[j].vel;
            
            Vector3 pos_diff = vec3_sub_vec3(pos, pos2);
            f64 distance = vec3_length(pos_diff);
            f64 mag = delta / (distance * distance * distance);
            
            vel = vec3_sub_vec3(vel, vec3_mul_f64(pos_diff, mass2 * mag));
            vel2 = vec3_add_vec3(vel2, vec3_mul_f64(pos_diff, mass * mag));
            
            (*bodies)[j].vel = vel2;
            
        loop_inner_bottom:
            j = j + 1i64;
            if (j < 5i64)
                goto loop_inner;
        
        (*bodies)[i].vel = vel;
        (*bodies)[i].pos = vec3_add_vec3(pos, vec3_mul_f64(vel, delta));
        
        i = i + 1i64;
        if (i < 5i64)
            goto loop_outer;
    
    return;
}

f64 energy(ptr(array(Body, 5)) bodies)
{
    f64 energy = 0.0f64;
    i64 i = 0i64;
    loop_head:
        Body body = (*bodies)[i];
        f64 mass = body.mass; 
        Vector3 vel = body.vel;
        Vector3 pos = body.pos;
        
        energy = energy + mass * vec3_sq_length(vel) * 0.5f64;
        
        i64 j = i + 1i64;
        if (j >= 5i64)
            goto loop_inner_bottom;
        loop_inner:
            Body body2 = (*bodies)[j];
            f64 mass2 = body2.mass; 
            Vector3 vel2 = body2.vel;
            Vector3 pos2 = body2.pos;
            
            Vector3 pos_diff = vec3_sub_vec3(pos, pos2);
            f64 dist = vec3_length(pos_diff);
            energy = energy - mass * mass2 * (1.0f64/dist);
        
            j = j + 1i64;
            if (j < 5i64)
                goto loop_inner;
        loop_inner_bottom:
        
        i = i + 1i64;
        if (i < 5i64)
            goto loop_head;
    
    return energy;
}

void offset_momentum(ptr(array(Body, 5)) bodies)
{
    f64 PI = 3.141592653589793f64;
    f64 SOLAR_MASS = 4.0f64 * PI * PI;
    i64 i = 1i64;
    loop_head:
        f64 ratio = (*bodies)[i].mass / SOLAR_MASS;
        (*bodies)[0i64].vel = vec3_sub_vec3((*bodies)[0i64].vel, vec3_mul_f64((*bodies)[i].vel, ratio));
        
        i = i + 1i64;
        if (i < 5i64)
            goto loop_head;
    
    return;
}

void nbody_bench()
{
    f64 PI = 3.141592653589793f64;
    f64 SOLAR_MASS = 4.0f64 * PI * PI;
    f64 DAYS_PER_YEAR = 365.24f64;
    
    //Vector3 bruh = Vector3 { 10000100.01143f64, 0.0f64, 0.0f64 };
    //print_float(10000100.01143f64);
    //print_float(bruh.x);
    //print_bytes(((&bruh.x) bit_as ptr(u8)), 8u64);
    //bruh.x = 10000100.01143f64;
    //print_float(bruh.x);
    //print_bytes(((&bruh.x) bit_as ptr(u8)), 8u64);
    
    array(Body, 5) bodies;
    bodies = [
        Body {
            Vector3 { 0.0f64, 0.0f64, 0.0f64 },
            Vector3 { 0.0f64, 0.0f64, 0.0f64 },
            SOLAR_MASS
        },
        Body {
            Vector3 { 4.84143144246472090e+00f64, -1.16032004402742839e+00f64, -1.03622044471123109e-01f64 },
            Vector3 { 1.66007664274403694e-03f64 * DAYS_PER_YEAR, 7.69901118419740425e-03f64 * DAYS_PER_YEAR, -6.90460016972063023e-05f64 * DAYS_PER_YEAR },
            9.54791938424326609e-04f64 * SOLAR_MASS
        },
        Body {
            Vector3 { 8.34336671824457987e+00f64, 4.12479856412430479e+00f64, -4.03523417114321381e-01f64 },
            Vector3 { -2.76742510726862411e-03f64 * DAYS_PER_YEAR, 4.99852801234917238e-03f64 * DAYS_PER_YEAR, 2.30417297573763929e-05f64 * DAYS_PER_YEAR },
            2.85885980666130812e-04f64 * SOLAR_MASS
        },
        Body {
            Vector3 { 1.28943695621391310e+01f64, -1.51111514016986312e+01f64, -2.23307578892655734e-01f64 },
            Vector3 { 2.96460137564761618e-03f64 * DAYS_PER_YEAR, 2.37847173959480950e-03f64 * DAYS_PER_YEAR, -2.96589568540237556e-05f64 * DAYS_PER_YEAR },
            4.36624404335156298e-05f64 * SOLAR_MASS
        },
        Body {
            Vector3 { 1.53796971148509165e+01f64, -2.59193146099879641e+01f64, 1.79258772950371181e-01f64 },
            Vector3 { 2.68067772490389322e-03f64 * DAYS_PER_YEAR, 1.62824170038242295e-03f64 * DAYS_PER_YEAR, -9.51592254519715870e-05f64 * DAYS_PER_YEAR },
            5.15138902046611451e-05f64 * SOLAR_MASS
        }
    ];
    
    //print_float(sun.mass);
    //print_float(bodies[0i64].mass);
    
    //print_float(4.84143144246472090e+00f64);
    //print_float(bodies[1i64].pos.x);
    //print_float(bodies[1i64].mass);
    
    offset_momentum(&bodies);
    
    f64 start_energy = energy(&bodies);
    print_float(start_energy);
    
    u64 i = 0u64;
    loop_head:
    
        advance(&bodies, 0.01f64);
        
        i = i + 1u64;
        if (i < 50000000u64)
            goto loop_head;
    
    f64 end_energy = energy(&bodies);
    print_float(end_energy);
    
    return;
}


struct linked_list {
    ptr(linked_list) next;
    ptr(u8) data;
}

f32 func_gravity2()
{
    linked_list asdf;
    asdf.next = &asdf;

    return 0.0f32;
}

/*
struct invalid_type {
    invalid_type next;
}
*/

/*
struct doubly_invalid_type_a {
    doubly_invalid_type_b next;
}
struct doubly_invalid_type_b {
    doubly_invalid_type_a next;
}
*/

/*
struct triply_invalid_type_a {
    triply_invalid_type_b next;
}
struct triply_invalid_type_b {
    triply_invalid_type_c next;
}
struct triply_invalid_type_c {
    triply_invalid_type_a next;
}
*/
